/* Copyright (C) 2002 Albert Tumanov

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

*/

// $Header: /cvsroot/pldoc/sources/src/javacc/Parser.jj,v 1.8 2004/07/21 09:41:38 altumano Exp $
//
options {
  //DEBUG_PARSER = true; DEBUG_TOKEN_MANAGER = true;
  IGNORE_CASE = true;
  STATIC = false;
  LOOKAHEAD = 1;
  DEBUG_LOOKAHEAD = false;
  CHOICE_AMBIGUITY_CHECK = 3;
  OTHER_AMBIGUITY_CHECK = 1;
  ERROR_REPORTING = true;
  JAVA_UNICODE_ESCAPE = true;
  UNICODE_INPUT = false;
  USER_TOKEN_MANAGER = false;
  USER_CHAR_STREAM = false;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  FORCE_LA_CHECK = false;
}

PARSER_BEGIN(PLSQLParser)

/* Copyright (C) 2002 Albert Tumanov

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

*/

package net.sourceforge.pldoc.parser;

import java.io.*;
import java.util.*;
import org.xml.sax.SAXException;
import org.w3c.dom.*;
import net.sourceforge.pldoc.*;
import uk.co.anyware.html.HTMLEscaper;
import org.xml.sax.SAXException;

public class PLSQLParser {

  private XMLWriter m_out;
  private boolean ignoreInformalComments = false;
  private boolean namesUppercase = false;
  private boolean namesLowercase = false;

  /** Sets the stream to receive output XML text.
  */
  public void setXMLWriter(XMLWriter out)
  {
    m_out = out;
  }

  /**
  * Sets to ignore informal comments (default false).
  */
  public void setIgnoreInformalComments(boolean ignoreInformalComments)
  {
    this.ignoreInformalComments = ignoreInformalComments;
  }

  /**
  * Sets conversion of all PL/SQL identifiers to uppercase (default false).
  */
  public void setNamesUppercase(boolean namesUppercase)
  {
    this.namesUppercase = namesUppercase;
  }

  /**
  * Sets conversion of all PL/SQL identifiers to lowercase (default false).
  */
  public void setNamesLowercase(boolean namesLowercase)
  {
    this.namesLowercase = namesLowercase;
  }

  /** Processes a package comment.
  * Searches for possible package-level formal comment before the current token.
  * If found, generates COMMENT element for the package.
  */
  private void processPackageComment(Token token)
      throws SAXException {
    Hashtable packageCommentTags = new Hashtable();
    String packageComment = null;

    // get the text, if present
    if (token != null && token.specialToken != null) {
      token = token.specialToken;
      int kind = token.kind;
      String comment = token.toString();
      if (comment != null && kind == FORMAL_COMMENT) {
        CommentParser commentParser = new CommentParser(comment);
        // get the package comment text
        packageComment = commentParser.getText();
        if (packageComment != null) {
          // extract tags from the package comment
          packageCommentTags.putAll(commentParser.getTags());
        }
      }
    }

    // print the package comment
    printPackageComment(packageComment, packageCommentTags);
  }

  /** Processes a package member.
  * Searches for possible package-level comment before the member.
  * If found, generates COMMENT element for the package.
  * For the package member, generates open tag with the given element name
  * with memberName as NAME attribute.
  * Inserts COMMENT_FIRST_LINE and COMMENT elements.
  * Closing member tag is NOT added.
  * @return table of tags found in the formal comment
  */
  private Hashtable processMemberComment(Token token, String elementName, String memberName)
      throws SAXException {
    String commentFirstLine = null, commentAll = null;
    String packageComment = null, returnComment = null;
    Hashtable tags = new Hashtable();
    Hashtable packageCommentTags = new Hashtable();

    // Should handle multiple comment blocks ? Then use "while".
    // Otherwise, use "if".
    while (token.specialToken != null) {

      token = token.specialToken;
      int kind = token.kind;
      String comment = token.toString();

      if (comment != null && (kind == FORMAL_COMMENT || ! ignoreInformalComments)) {

        CommentParser commentParser = new CommentParser(comment);
        // get package comment, if any
        packageComment = commentParser.getPackageComment();
        if (packageComment != null) {
          // extract tags from package comment
          packageCommentTags.putAll(commentParser.getTags());
        }

        // only the main sentence from the first comment block is used, others are ignored
        if (commentFirstLine == null) {
          commentFirstLine = commentParser.getMainSentence();
          if (kind != FORMAL_COMMENT) {
            if(ignoreInformalComments) {
              // ignore informal comments
              commentFirstLine = "";
            } else {
              // informal comment may have "<" etc inside
              commentFirstLine = HTMLEscaper.escape(commentFirstLine);
            }
          }
        }

        // only the comment text from the first comment block is used, others are ignored
        if (commentAll == null) {
          commentAll = commentParser.getText();
          if (kind != FORMAL_COMMENT) {
            if(ignoreInformalComments) {
              // ignore informal comments
              commentAll = "";
            } else {
              // informal comment may have "<" etc inside
              commentAll = HTMLEscaper.escape(commentAll);
            }
          }
        }

        // tags are out together (duplicate names will be overwritten)
        tags.putAll(commentParser.getTags());

      }

    }

    // print package-level stuff
    printPackageComment(packageComment, packageCommentTags);

    // now start the program unit
    m_out.pushAttribute("NAME", purifyIdentifier(memberName));
    m_out.startElement(purifyIdentifier(elementName));
    if (commentFirstLine != null) {
      m_out.startElement("COMMENT_FIRST_LINE");
      m_out.cdata(commentFirstLine);
      m_out.endElement("COMMENT_FIRST_LINE");
    }
    if (commentAll != null) {
      m_out.startElement("COMMENT");
      m_out.cdata(commentAll);
      m_out.endElement("COMMENT");
    }
    return tags;
  }

  /** Prints the package comment into the stream.
  */
  private void printPackageComment(String packageComment, Hashtable packageCommentTags)
      throws SAXException {
    // print package-level stuff
    if (packageComment != null) {
      // print package comment, it goes under PACKAGE tag
      m_out.startElement("COMMENT");
      m_out.cdata(packageComment);
      m_out.endElement("COMMENT");

      // modified by Steve Holt - start

      // print TAGs
      String comment = null;

      Iterator keyIt = packageCommentTags.keySet().iterator();
      while (keyIt.hasNext()) {

        String key = (String)keyIt.next();
        Collection tagValues = (Collection) packageCommentTags.get(key);
        if (tagValues != null) {
          for(Iterator it = tagValues.iterator(); it.hasNext(); ) {
            comment = (String) it.next();
            m_out.pushAttribute("TYPE", purifyIdentifier(key));
            m_out.startElement("TAG");
            if (comment != null) {
              m_out.startElement("COMMENT");
              m_out.cdata(comment);
              m_out.endElement("COMMENT");
            }
            m_out.endElement("TAG");
          }
        }
      }

      // modified by Steve Holt - end

    }
  }

  /**
  * Gets the comment for the parameter named <code>paramName</code> from the table of tags.
  *
  * @param paramName	name of the parameter
  * @param tags		table of tags
  * @return		comment or <code>null</code> if comment not found
  */
  private String getParamComment(String paramName, Hashtable tags)
  {
    String paramComment = null;
    Collection tagValues = (Collection) tags.get("@param");
    if (tagValues != null) {
      Iterator it = tagValues.iterator();
      while (it.hasNext()) {
        String value = (String) it.next();

        // extract parameter name
        String extractedParamName = null;
        // use tokenizer, because tokens maybe separated by spaces or tabs
        StringTokenizer st = new StringTokenizer(value);
        // extract parameter name, the rest is the comment
        if (st.hasMoreTokens()) {
          extractedParamName = st.nextToken();
        }

        if (extractedParamName != null && extractedParamName.equalsIgnoreCase(paramName)) {
          int paramCommentStart = value.indexOf(extractedParamName) + extractedParamName.length() + 1;
          if (paramCommentStart < value.length()) {
            paramComment = value.substring(paramCommentStart).trim();
          }
          break;
        }
      }
    }
    return paramComment;
  }


  /** Purifies an identifier: changes to uppercase, removes quotes.
  */
  private String purifyIdentifier(String name)
  {
    // change case as requested in settings
    if (namesUppercase) {
      name = name.toUpperCase();
    }
    if (namesLowercase) {
      name = name.toLowerCase();
    }

    // remove double quotes
    StringBuffer s = new StringBuffer(name);
    for (int i=0; i<s.length(); i++) {
      if (s.charAt(i) == '"') {
        s.deleteCharAt(i);
        i--;
      }
    }
    return s.toString();
  }

  /**
   * main method, for testing only.
   * @param args
   */
  public static void main(String[] args)
      throws ParseException, SAXException {

    PLSQLParser parser = new PLSQLParser(System.in);
    parser.input();

    String s;
    s = "qwerty";
    System.out.println(s + " -> " + parser.purifyIdentifier(s));
    s = "\"qwerty\"";
    System.out.println(s + " -> " + parser.purifyIdentifier(s));
    s = "\"qwerty\".uiop";
    System.out.println(s + " -> " + parser.purifyIdentifier(s));
    s = "\"qwerty\".\"uiop\"";
    System.out.println(s + " -> " + parser.purifyIdentifier(s));
  }

}

PARSER_END(PLSQLParser)
// Copyright (C) 2002 Albert Tumanov

void input() throws SAXException : {}
{
  (
    (
			LOOKAHEAD(6) packageSpec() 
		| 	LOOKAHEAD(4) typeSpec() 
		|	alterType()
			/*TODO package body parsing not supported | LOOKAHEAD(6) packageBody() */ 
		| sqlPlusCommand() 
		| LOOKAHEAD(6) table() 
		| view() 
		| comment()
	)

    ("/")*
  )*
  <EOF>
}

void sqlPlusCommand() : {}
{
  // e.g. SHOW ERRORS, GRANT EXECUTE ON ... TO ...
  (LOOKAHEAD(2) (<IDENTIFIER>["."<IDENTIFIER>] | <EXECUTE> | <SET> | <ON> | <TO> | <PUBLIC> | "(" | ")" | <STRING_LITERAL>) )+
  [";"]
}

/** Recognizes a numeric literal.
* This may look like token, but it isn't. Not atomic enough.
* E.g. "+1" would be valid literal, which make parsing of "i+1" impossible
* (here, we have tokens "i", "+" and "1")
*/
Token numericLiteral() :
{ Token main = null; }
{
  (
    ["-" | "+"] main=<UNSIGNED_NUMERIC_LITERAL>
  )
  { return main; }
}

void packageSpec() throws SAXException :
{ Token schema = null, name = null, tokenCreate = null, tokenPackage = null, tokenIsAs = null; }
{
  [tokenCreate=<CREATE> [<OR> <REPLACE>]]
  tokenPackage=<PACKAGE> (LOOKAHEAD(2) schema=ID()".")? name=ID()
  {
    String schemaString = "";
    if (schema != null) {
      schemaString = schema.toString();
    }
    // now start printing the package
    m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
    m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString.toString()));
    m_out.startElement("PACKAGE");
    // possibly, package comment is here
    processPackageComment(tokenCreate);
    processPackageComment(tokenPackage);
  }
  (tokenIsAs=<AUTHID> (<CURRENT_USER> | <DEFINER>))?
  {
    // possibly, package comment is here
    processPackageComment(tokenIsAs);
  }
  (tokenIsAs=<IS> | tokenIsAs=<AS>)
  {
    // possibly, package comment is here
    processPackageComment(tokenIsAs);
  }

    declarativeSection(true)

  <END> [ID()] ";"
  { m_out.endElement("PACKAGE"); }
}

void packageBody() throws SAXException :
{ Token name=null; }
{
  [<CREATE> [<OR> <REPLACE>]]
  <PACKAGE> <BODY> (LOOKAHEAD(2) ID()".")? name=ID()
  {
    m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
    m_out.startElement("PACKAGE_BODY");
  }
  (<IS> | <AS>)

    declarativeSection(true)

  [<BEGIN> (statement())+] <END> [ID()] ";"
  { m_out.endElement("PACKAGE_BODY"); }
}

void declarativeSection(boolean isPackageLevel) throws SAXException :
{}
{
    (
/*
    collection_type_definition(isPackageLevel)
    objectDeclaration(isPackageLevel) |
    record_type_definition(isPackageLevel) |
    LOOKAHEAD(2)
    recordDeclaration(isPackageLevel) |
    LOOKAHEAD(2)
*/
    pragma(isPackageLevel) |
    LOOKAHEAD(2)
    exceptionDeclaration(isPackageLevel) |
    LOOKAHEAD(2)
    subtype_definition(isPackageLevel) |
    LOOKAHEAD(4)
    variableOrConstantDeclaration(isPackageLevel) |
    LOOKAHEAD(2)
    cursorSpec(isPackageLevel) |
    cursorBody(isPackageLevel) |
    collectionDeclaration(isPackageLevel) |
    programUnit(isPackageLevel)
    )*
}

void alterType() throws SAXException :
{
	Token id=null; 
}
{
	// We deal with "ALTER TYPE type"
	<ALTER> <TYPE> id=ID()
	
	//
	alterTypeAddMemberFunction(id)
}

void alterTypeAddMemberFunction(Token type) throws SAXException :
{
	Token member;
}
{
	<ADD> <MEMBER> programUnit(true)
}



void typeSpec() throws SAXException :
{
	Token tokenCreate=null, tokenIdent=null, schema=null, name=null; 
	String schemaString;
}
{
	[tokenCreate=<CREATE> [<OR> <REPLACE>]]
	tokenIdent=<TYPE> (LOOKAHEAD(2) schema=ID()".")? name=ID()
	{
		schemaString = (schema == null) ? "" : schema.toString();
	}

	( LOOKAHEAD(2) typeNestedTable(tokenCreate, tokenIdent, schemaString, name.toString()) 
	| LOOKAHEAD(2) typeVarray(tokenCreate, tokenIdent, schemaString, name.toString()) 
	| typeObject(tokenCreate, tokenIdent, schemaString, name.toString()) 
	| typeUnder(tokenCreate, tokenIdent, schemaString, name.toString()) 
	)
}

void typeNestedTable(Token tokenCreate, Token tokenIdent, String schema, String name) throws SAXException :
{
	Token datatype=null;
}
{
	(<IS> | <AS>) <TABLE> <OF> datatype=ID() (";")?
	{
		// now start printing the package
		m_out.pushAttribute("TYPE", "NESTED-TABLE");
		m_out.pushAttribute("NAME", purifyIdentifier(name));
		m_out.pushAttribute("SCHEMA", purifyIdentifier(schema));
		m_out.pushAttribute("DATATYPE", purifyIdentifier(datatype.toString()));
		m_out.startElement("TYPE");
		// possibly, package comment is here
		processPackageComment(tokenCreate);
		processPackageComment(tokenIdent);
		m_out.endElement("TYPE");
	}
}

void typeVarray(Token tokenCreate, Token tokenIdent, String schema, String name) throws SAXException :
{
	Token size=null, datatype=null;
}
{
	(<IS> | <AS>) <VARRAY> "(" size=numericLiteral() ")" <OF> datatype=ID() (";")?
	{
		// now start printing the package
		m_out.pushAttribute("TYPE", "VARRAY");
		m_out.pushAttribute("NAME", purifyIdentifier(name));
		m_out.pushAttribute("SCHEMA", purifyIdentifier(schema));
		m_out.pushAttribute("DATATYPE", purifyIdentifier(datatype.toString()));
		m_out.startElement("TYPE");
		// possibly, package comment is here
		processPackageComment(tokenCreate);
		processPackageComment(tokenIdent);
		m_out.endElement("TYPE");
	}
}

void typeUnder(Token tokenCreate, Token tokenIdent, String schema, String name) throws SAXException :
{
	Token supertype = null;
}
{
	<UNDER> supertype=ID() "("
	{
		// now start printing the package
		m_out.pushAttribute("TYPE", "OBJECT");
		m_out.pushAttribute("NAME", purifyIdentifier(name));
		m_out.pushAttribute("SCHEMA", purifyIdentifier(schema));
		m_out.startElement("TYPE");
		// possibly, package comment is here
		processPackageComment(tokenCreate);
		processPackageComment(tokenIdent);
	}

	typeDeclarativeSection(true) ( "," typeDeclarativeSection(true) )*

	")" 

	// Optional NOT FINAL or FINAL
	[[<NOT>] <FINAL>]

	(";")?

	{ m_out.endElement("TYPE"); }
}

void typeObject(Token tokenCreate, Token tokenIdent, String schema, String name) throws SAXException : {}
{
	(<IS> | <AS>) <OBJECT> "("
	{
		// now start printing the package
		m_out.pushAttribute("TYPE", "OBJECT");
		m_out.pushAttribute("NAME", purifyIdentifier(name));
		m_out.pushAttribute("SCHEMA", purifyIdentifier(schema));
		m_out.startElement("TYPE");
		// possibly, package comment is here
		processPackageComment(tokenCreate);
		processPackageComment(tokenIdent);
	}

/*
	(tokenIsAs=<AUTHID> (<CURRENT_USER> | <DEFINER>))?
	{
		// possibly, package comment is here
		//processPackageComment(tokenIsAs);
	}
*/

	typeDeclarativeSection(true) ( "," typeDeclarativeSection(true) )*

	")" 

	// Optional NOT FINAL or FINAL
	[[<NOT>] <FINAL>]
  
	(";")?

	{ m_out.endElement("TYPE"); }

}

void typeDeclarativeSection(boolean isPackageLevel) throws SAXException :
{}
{
    (
		LOOKAHEAD(2) typeMapMemberDeclaration()
	|	LOOKAHEAD(2) typeMemberDeclaration()
	|	LOOKAHEAD(4) typeVariableDeclaration()
    )*
}

void typeMapMemberDeclaration() throws SAXException :
{
	Token start=null;
	Token name=null;
	String type;
	String elementName = "MEMBER-FUNCTION";
}
{
  start=<MAP> <MEMBER> <FUNCTION> name=ID() <RETURN> type=datatype() 
  {
      processMemberComment(start, elementName, name.toString());
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.startElement("RETURN");
      m_out.endElement("RETURN");
      m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.endElement(elementName);
  }
}

void typeMemberDeclaration() throws SAXException :
{
	Token start=null;
	Token name=null;
	String type;
	String elementName = "MEMBER-FUNCTION";
}
{
  start=<MEMBER> <FUNCTION> name=ID() <RETURN> type=datatype() (<CASCADE>)?
  {
      processMemberComment(start, elementName, name.toString());
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.startElement("RETURN");
      m_out.endElement("RETURN");
      m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.endElement(elementName);
  }
}

void typeVariableDeclaration() throws SAXException :
{
	Token name=null;
	String type;
	String elementName = "VARIABLE";
}
{
  name=ID() type=datatype()
  {
      processMemberComment(name, elementName, name.toString());
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.startElement("RETURN");
      m_out.endElement("RETURN");
      m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.endElement(elementName);
  }
}

void programUnit(boolean isPackageLevel) throws SAXException :
{
  Token start, name;
  String type;
  Hashtable tags;
}
{
  (
  (start=<FUNCTION>|start=<PROCEDURE>) name=ID()
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(start, start.toString().toUpperCase(), name.toString());
    } else {
      tags = new Hashtable();
    }
  }
  ( "(" parameterDeclaration(tags) ( "," parameterDeclaration(tags) )* ")" )*
  [<RETURN> type=datatype()
  {
    // element generated only on the package level
    if (isPackageLevel) {
      // @return
      String returnComment = null;
      Collection tagValues = (Collection) tags.get("@return");
      if (tagValues != null) {
        for(Iterator it = tagValues.iterator(); it.hasNext(); )
          returnComment = (String) it.next();
      }
      m_out.pushAttribute("TYPE", purifyIdentifier(type.toString()));
      m_out.startElement("RETURN");
      if (returnComment != null) {
        m_out.startElement("COMMENT");
        m_out.cdata(returnComment);
        m_out.endElement("COMMENT");
      }
      m_out.endElement("RETURN");
    }
  }
  ]
  {
    // element generated only on the package level
    if (isPackageLevel) {

      // modified by Steve Holt - start

      String comment = null;

      Iterator keyIt = tags.keySet().iterator();
      while (keyIt.hasNext()) {

        String key = (String)keyIt.next();
        Collection tagValues = (Collection) tags.get(key);
        if (tagValues != null) {
          for(Iterator it = tagValues.iterator(); it.hasNext(); ) {
            comment = (String) it.next();
            m_out.pushAttribute("TYPE", purifyIdentifier(key));

            // additional attribute NAME for @throws
            if (key.equals("@throws")) {
              // extract when first word - it's the exception name
              StringTokenizer st = new StringTokenizer(comment);
              if (st.hasMoreTokens()) {
                String exceptionName = st.nextToken();
                m_out.pushAttribute("NAME", purifyIdentifier(exceptionName));
                comment = comment.substring(exceptionName.length());
              }
            }

            // start TAG element
            m_out.startElement("TAG");
            if (comment != null) {
              m_out.startElement("COMMENT");
              m_out.cdata(comment);
              m_out.endElement("COMMENT");
            }
            m_out.endElement("TAG");
          }
        }
      }

      // modified by Steve Holt - end

    }
  }
  (<DETERMINISTIC> | <PARALLEL_ENABLE> | <PIPELINED> | <CASCADE> | <RESULT_CACHE>)*
  // body
  [
    (<IS> | <AS>)
    (
      LOOKAHEAD(2)
      callSpecTail(isPackageLevel)
      |
      (
        declarativeSection(false)
        <BEGIN> (LOOKAHEAD(statement()) statement())+
        [ <EXCEPTION>
          (<WHEN> ID() <THEN> (statement())+ )+
        ]
        <END> [ID()]
      )
    )
  ]
  // end of body
  ";"
  )
  {
    // element generated only on the package level
    if (isPackageLevel) {
      m_out.endElement(purifyIdentifier(start.toString().toUpperCase()));
    }
  }
}

void parameterDeclaration(Hashtable tags) throws SAXException :
{
  Token name;
  String paramMode = "", paramType, paramDefault = "";
}
{
  name=ID()
  // the order of outer "|" is important !
  ( LOOKAHEAD(2) ( LOOKAHEAD(2) ( (<OUT>{paramMode = "OUT";}|(<IN> <OUT>{paramMode = "IN OUT";})) (LOOKAHEAD(2) <NOCOPY>)? ) | <IN> ) )?
  paramType=datatype()
  ( (":="|<_DEFAULT>) paramDefault=expression() )?
  {
    String paramName = name.toString();
    String paramComment = getParamComment(paramName, tags);
    m_out.pushAttribute("NAME", purifyIdentifier(paramName));
    m_out.pushAttribute("MODE", paramMode);
    m_out.pushAttribute("TYPE", purifyIdentifier(paramType));
    m_out.pushAttribute("DEFAULT", purifyIdentifier(paramDefault));
    m_out.startElement("ARGUMENT");
    if (paramComment != null) {
      m_out.startElement("COMMENT");
      m_out.cdata(paramComment);
      m_out.endElement("COMMENT");
    }
    m_out.endElement("ARGUMENT");
  }
}

String datatype() :
{ String name; }
{
  (
    // this should be first
    LOOKAHEAD(2) name=scalar_datatype_name()
    |
    (
      ( [LOOKAHEAD(2) <REF>] name=qualifiedName() ["%" (<TYPE>{name += "%TYPE";}|<ROWTYPE>{name += "%ROWTYPE";})] )
    )
  )
  { return name; }
}

String scalar_datatype_name() :
{ Token size=null, precision=null;
  String name = null;
}
{
  (
  // scalar types - numeric:
  <BINARY_INTEGER> | <DEC> | <DECIMAL> | (<DOUBLE><PRECISION> {name = "DOUBLE PRECISION";}) |
  <FLOAT> | <INT> | <INTEGER> | <NATURAL> |
  <NATURALN> | <NUMBER> | <NUMERIC> | <PLS_INTEGER> | <POSITIVE> | <POSITIVEN> | <REAL> | <SIGNTYPE> |
  <SMALLINT> |

  // scalar types - character:
  <CHAR> | <CHARACTER> | LOOKAHEAD(2) (<LONG><RAW> {name = "LONG RAW";}) | <LONG> |
  <NCHAR> | <NVARCHAR2> | <RAW> | <ROWID> |
  <STRING> | <UROWID> | <VARCHAR> | <VARCHAR2> |

  // scalar types - boolean:
  <BOOLEAN> |

  // composite types
  <TABLE> | <VARRAY> | (<VARYING><ARRAY> {name = "VARYING ARRAY";}) |
  // <RECORD> - defined elsewhere

  // LOB types
  <BFILE> | <BLOB> | <CLOB> | <NCLOB> |

  // reference types
  (<REF><CURSOR> {name = "REF CURSOR";}) |
  //<REF> object_type - defined elsewhere

  // scalar types - date/time:
  <DATE> |
  LOOKAHEAD(2) (<INTERVAL><DAY><TO><SECOND> {name = "INTERVAL DAY TO SECOND";}) |
  (<INTERVAL><YEAR><TO><MONTH> {name = "INTERVAL YEAR TO MONTH";}) |
  LOOKAHEAD(3) (<TIMESTAMP> <WITH> <LOCAL> <TIME> <ZONE> {name = "TIMESTAMP WITH LOCAL TIME ZONE";}) |
  LOOKAHEAD(2) (<TIMESTAMP> <WITH> <TIME> <ZONE> {name = "TIMESTAMP WITH TIME ZONE";}) |
  <TIMESTAMP>
  )

  {
    if (name == null) {
      name = token.toString();
    }
  }
  (LOOKAHEAD(2) 
    "(" size=numericLiteral() {name += "(" + size;}
     ["," precision=numericLiteral() {name += "," + precision;}]
     [<BYTE> { name += " byte"; }]
    ")" {name += ")";})?
  { return name; }
}

String qualifiedName() :
{
  Token schema = null;
  Token packageName = null;
  Token packageMember = null;
  Token packageMembersMember = null;
  Token name = null;
}
{
  (
    [LOOKAHEAD(2) schema=<IDENTIFIER> "."]   // schema
    [LOOKAHEAD(2) packageName=<IDENTIFIER> "."]   // package
    [LOOKAHEAD(2) packageMember=<IDENTIFIER> "."]   // package member
    [LOOKAHEAD(2) packageMembersMember=<IDENTIFIER> "."]   // package member's member
    name=ID() 	// simple or prefixed with schema
    ["@" <IDENTIFIER>]					// remote
  )
  {
    String fullName;
    fullName =
      ((schema == null)? "":schema + ".") +
      ((packageName == null)? "":packageName + ".") +
      ((packageMember == null)? "":packageMember + ".") +
      ((packageMembersMember == null)? "":packageMembersMember + ".") +
      ((name == null)? "":name.toString());
    return fullName;
  }
}

void statement() throws SAXException :
{}
{
  // null statement
  LOOKAHEAD(2) <NULL> ";" |

  // return
  LOOKAHEAD(2) <RETURN> expression() ";" |

  // function call (should be the last to recognize)
  LOOKAHEAD(variableOrFunctionCall() ";")
    variableOrFunctionCall() ";" |

  // assignment
  LOOKAHEAD(qualifiedName()[(expression())] ":=")
    qualifiedName()[(expression())] ":=" expression() ";" |

  // FOR
  LOOKAHEAD(2)
  <FOR> ID() <IN>
    (
      LOOKAHEAD(4) ([LOOKAHEAD(2) <REVERSE>] expression() [".."expression()]) |
      (ID() "(" expression() ("," expression())* ")") |
      ("(" select() ")")
    )
  <LOOP> (statement())+ <END> <LOOP> [ID()] ";" |

  // WHILE
  <WHILE> expression() <LOOP> (statement())+ <END> <LOOP> [ID()] ";" |

  // LOOP
  <LOOP> (statement())+ <END> <LOOP> [ID()] ";" |

  // EXIT
  <EXIT> [ID()] <WHEN> expression() ";" |

  // IF
  LOOKAHEAD(2) <IF> expression() <THEN> (LOOKAHEAD((statement())+) statement())+
  [(<ELSIF>|<ELSE>) (statement())+]
  <END> <IF> ";" |

  // compound statement
  <BEGIN> (statement())+ <END> ";" |

  // raise
  LOOKAHEAD(2) <RAISE> ID() ";" |

  // select
  select() ";"
  // insert
  // update
  // delete
  // label <<ID()>>

}

void subtype_definition(boolean isPackageLevel) throws SAXException :
{
  Token start, subtype_name=null, constraint=null, element_type=null;
  Token collection = null, collection2 = null;
  String baseType = null, returnType = null, indexBy = null;
  Hashtable tags = null;
  int lastField = 0;
}
{

  (
    ( start=<SUBTYPE> subtype_name=<IDENTIFIER>
      {
        // element generated only on the package level
        if (isPackageLevel) {
          tags = processMemberComment(start, "TYPE", subtype_name.toString());
        }
      }
      <IS> baseType=datatype() ("(" constraint=<IDENTIFIER> ")")? (<NOT> <NULL>)?
      {
        returnType = baseType;
        if (constraint != null) {
          returnType += "(" + constraint + ")";
        }
      }
    ) |
    ( start=<TYPE> subtype_name=<IDENTIFIER>
      {
        // element generated only on the package level
        if (isPackageLevel) {
          tags = processMemberComment(start, "TYPE", subtype_name.toString());
        }
      }
      <IS>
      (
        (<RECORD> {baseType = "RECORD";} "(" fieldDeclaration(isPackageLevel, tags) ("," fieldDeclaration(isPackageLevel, tags))* ")" )
        {
          returnType = "RECORD";
          // end for
        }
        |
        ((collection=<TABLE> | collection=<VARRAY> | collection=<VARYING> collection2=<ARRAY>)["(" constraint=numericLiteral() ")"]
        <OF> baseType=datatype() (<NOT> <NULL>)? (<INDEX> <BY> indexBy=datatype())?)
        {
          returnType = collection.toString();
          if (collection2 != null) {
            returnType += " " + collection2;
          }
          if (constraint != null) {
            returnType += "(" + constraint + ")";
          }
          returnType += " OF " + baseType + " INDEX BY " + indexBy;
        }
        |
        <REF> <CURSOR> [<RETURN> baseType=datatype()]
        {
          returnType = "REF CURSOR";
          if (baseType != null) {
            returnType += " RETURN " + baseType;
          }
        }
      )
    )
  )
  ";"
  {
    // element generated only at the package level
    if (isPackageLevel) {
      if (returnType != null) {
        m_out.pushAttribute("TYPE", returnType);
        m_out.element("RETURN");
      }
      m_out.endElement("TYPE");
    }
  }
}

void fieldDeclaration(boolean isPackageLevel, Hashtable tags) throws SAXException :
{
  Token name;
  String dataType;
}
{
  name=ID() dataType=datatype() ( (<NOT> <NULL>)? (":=" | <_DEFAULT>) expression() )?
  {
    if (isPackageLevel) {
      String paramName = name.toString();
      String paramComment = getParamComment(paramName, tags);
      m_out.pushAttribute("NAME", purifyIdentifier(paramName));
      m_out.pushAttribute("TYPE", purifyIdentifier(dataType));
      m_out.startElement("FIELD");
      if (paramComment != null) {
        m_out.startElement("COMMENT");
        m_out.cdata(paramComment);
        m_out.endElement("COMMENT");
      }
      m_out.endElement("FIELD");
    }
  }
}

void collection_type_definition() : {} { <IDENTIFIER> }
void collectionDeclaration(boolean isPackageLevel) : {} { <IDENTIFIER> }
void objectDeclaration() : {} { <IDENTIFIER> }

/** Java stored procedure, external function*/
void callSpecTail(boolean isPackageLevel) : {}
{
  <LANGUAGE> (/*"C"*/<IDENTIFIER> | <JAVA>)

  /*"NAME"*/<IDENTIFIER> <STRING_LITERAL>
  /* ### or:
    LIBRARY library_name
    [NAME c_string_literal_name]
    [WITH CONTEXT]
    [PARAMETERS (external_parameter[, external_parameter]...)];

    Where library_name is the name of your alias library, c_string_literal_name is the name of your external C procedure, and external_parameter stands for:

    {  CONTEXT
     | SELF [{TDO | property}]
     | {parameter_name | RETURN} [property] [BY REFERENCE] [external_datatype]}

    where property stands for:

    {INDICATOR [{STRUCT | TDO}] | LENGTH | MAXLEN | CHARSETID | CHARSETFORM}
  */
}

/** Cursor (common part of specification and body) */
void cursorUnit(boolean isPackageLevel) throws SAXException :
{
  Token start, name;
  String type;
  Hashtable tags = new Hashtable();
}
{
  (
  start=<CURSOR> name=ID()
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(start, start.toString().toUpperCase(), name.toString());
    } else {
      tags = new Hashtable();
    }
  }
  ( "(" parameterDeclaration(tags) ( "," parameterDeclaration(tags) )* ")" )*
  [<RETURN> type=datatype()
  {
    // element generated only on the package level
    if (isPackageLevel) {
      String returnComment = null;
      Collection tagValues = (Collection) tags.get("@return");
      if (tagValues != null) {
        Iterator it = tagValues.iterator();
        while (it.hasNext())
          returnComment = (String) it.next();
      }
      m_out.pushAttribute("TYPE", purifyIdentifier(type.toString()));
      m_out.startElement("RETURN");
      if (returnComment != null) {
        m_out.startElement("COMMENT");
        m_out.cdata(returnComment);
        m_out.endElement("COMMENT");
      }
      m_out.endElement("RETURN");
    }
  }
  ]
  )
  {
    // element generated only on the package level
    if (isPackageLevel) {
      m_out.endElement(purifyIdentifier(start.toString().toUpperCase()));
    }
  }
  (";" | <IS> select() ";")
}

void cursorSpec(boolean isPackageLevel) throws SAXException : {}
{
  cursorUnit(isPackageLevel)
}

void cursorBody(boolean isPackageLevel) throws SAXException : {}
{
  cursorUnit(isPackageLevel)
//  <IS> select() ";"
}


/* EXPRESSIONS */

/** This production allows type-ignorant expressions with boolean, character,
* numeric and data variables or function calls intermixed.
* Without that, would need to know types of variables and return types of function calls,
* not possible without a symbol table.
*/

/*###
void expression() : {}
{
  "(" expression() ")"
  |
  "**" expression()
  |
  <CASE> <WHEN> expression() <THEN> expression() <ELSE> expression() <END>
  |
  (
    expressionTerm()
    ( LOOKAHEAD(2) (<AND> | <OR> | "||" | "+" | "-" | "*" | "/") expression() )*
    //### +other_boolean_form !
  )
}
###*/
/** This is not term in classical sense.
* Just had to split the left recursion.
*/
/*###
void expressionTerm() : {}
{
  LOOKAHEAD(2) (LOOKAHEAD(2) <NOT>)?
  variableOrFunctionCall() | numericLiteral()
    | LOOKAHEAD(2) <TRUE> | LOOKAHEAD(2) <FALSE>
    | <CHARACTER_LITERAL> | <STRING_LITERAL> |
  LOOKAHEAD(2) ((<IDENTIFIER>|<SQL>) "%" "ROWCOUNT") |
  qualifiedName()
  (
    "." ("COUNT" | "FIRST" | "LAST" | "LIMIT" | (("NEXT"|<PRIOR>|<EXISTS>) "(" numericLiteral() ")") )
    |
    "%" ("FOUND"|"ISOPEN"|"NOTFOUND"|("BULK_ROWCOUNT" "(" numericLiteral() ")"))
  )
}
###*/

String expression() :
{ String result = "", fname = ""; Token token = null;}
{
  (
  LOOKAHEAD(2) (<CASE> <WHEN> expression() <THEN> expression() <ELSE> expression() <END>)
  |
  LOOKAHEAD(2) (<CASE> expression() <WHEN> expression() <THEN> expression() <ELSE> expression() <END>)
  |
  ("(" result = expression() ")")
  |
  (
    (
      LOOKAHEAD(2) (LOOKAHEAD(2) <NOT>)?
      // function call must be before variable name, otherwise it will be confused
      fname=variableOrFunctionCall() {result += fname;} | token=numericLiteral() {result += token;}
        | LOOKAHEAD(2) <TRUE> | LOOKAHEAD(2) <FALSE> | <CHARACTER_LITERAL> | <STRING_LITERAL> |
      LOOKAHEAD(2) ((<IDENTIFIER>|<SQL>) "%" "ROWCOUNT") |
      LOOKAHEAD(2)
      ( <IDENTIFIER> "." ("COUNT" | "FIRST" | "LAST" | "LIMIT" | (("NEXT"|<PRIOR>|<EXISTS>) "(" numericLiteral() ")") ) ) |
      ( <IDENTIFIER> "%" ("FOUND"|"ISOPEN"|"NOTFOUND"|("BULK_ROWCOUNT" "(" numericLiteral() ")")) ) |
      ( <SQL> "%" "BULK_ROWCOUNT" "(" numericLiteral() ")" )
      // other_boolean_form:
      //### | expression() ( relationalOperator() expression() | <IS> [<NOT>] <NULL> /*### | [<NOT>]...*/)
    )
    ["**" expression()]
    ( LOOKAHEAD(2) (<AND> | <OR> | "||" | "+" | "-" | "*" | "/" | relationalOperator()) expression() )*
  )
  )
  { return result; }
}

void relationalOperator() :
{}
{
  "=" | "<>" | "!=" | "~=" | "^=" | "<" | ">" | "<=" | ">="
}

String variableOrFunctionCall() :
{ String token; }
{
  (
  token=qualifiedName()
  [
    "("
    [
            [LOOKAHEAD(2) <IDENTIFIER> "=>"] expression()
      ( "," [LOOKAHEAD(2) <IDENTIFIER> "=>"] expression() )*
    ]
    ")"
  ]
  ) {return token;}
}

/* LITERALS */
/*
void numericLiteral() : {} { <IDENTIFIER> }
void integer() : {} { <IDENTIFIER> }
void realNumber() : {} { <IDENTIFIER> }
void stringLiteral() : {} { <IDENTIFIER> }
void booleanLiteral() : {} { <IDENTIFIER> }
*/

/* Constants and Variables */
/*void variableDeclaration(boolean isPackageLevel) :
{ Token variableName=null; Hashtable tags = null;
  String variableType;
}
{
  variableName=<IDENTIFIER> variableType=datatype() [[<NOT> <NULL>] (":=" | <_DEFAULT>) expression()] ";"
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(variableName, "VARIABLE", variableName.toString());
      m_out.pushAttribute("TYPE", purifyIdentifier(variableType));
      m_out.startElement("RETURN");
      m_out.endElement("RETURN");
      m_out.endElement("VARIABLE");
    }
  }
}*/

/*void constantDeclaration(boolean isPackageLevel) :
{ Token constantName = null;
  String constantType;
  Hashtable tags = null;
}
{
  constantName=ID() <CONSTANT> constantType=datatype()
  [<NOT> <NULL>]
  (":=" | <_DEFAULT>) expression() ";"
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(constantName, "CONSTANT", constantName.toString());
      m_out.pushAttribute("TYPE", "CONSTANT " + purifyIdentifier(constantType));
      m_out.startElement("RETURN");
      m_out.endElement("RETURN");
      m_out.endElement("CONSTANT");
    }
  }
}*/

void variableOrConstantDeclaration(boolean isPackageLevel) throws SAXException :
{ Token name=null;
  String type;
  Hashtable tags = null;
  String elementName = "VARIABLE";
}
{
  name=ID() [LOOKAHEAD(2) <CONSTANT> {elementName = "CONSTANT";}] type=datatype()
  [[<NOT> <NULL>]
  (":=" | <_DEFAULT>) expression()] ";"
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(name, elementName, name.toString());
      m_out.pushAttribute("TYPE", purifyIdentifier(type));
      m_out.startElement("RETURN");
      m_out.endElement("RETURN");
      m_out.endElement(elementName);
    }
  }
}

void datatypeDeclaration() : {} { <IDENTIFIER> }

void pragma(boolean isPackageLevel) throws SAXException :
{ Token start,name,functionName,exceptionName,errorNumber; Hashtable tags = null; }
{
  start=<PRAGMA>
  (
    name=<SERIALLY_REUSABLE>
    |
    name=<AUTONOMOUS_TRANSACTION>
    |
    name=<RESTRICT_REFERENCES> "(" (functionName=ID() /*| <_DEFAULT>*/)
    ("," (ID() | <STRING_LITERAL>) )+  ")"
    |
    name=<EXCEPTION_INIT> "(" exceptionName=<IDENTIFIER> "," errorNumber=numericLiteral() ")"
  )
  ";"
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(start, start.toString().toUpperCase(), name.toString());
      m_out.endElement("PRAGMA");
    }
  }
}

void exceptionDeclaration(boolean isPackageLevel) throws SAXException :
{ Token exception_name; Hashtable tags = null; }
{
  exception_name=<IDENTIFIER> <EXCEPTION> ";"
  {
    // element generated only on the package level
    if (isPackageLevel) {
      tags = processMemberComment(exception_name, "EXCEPTION", exception_name.toString());
      m_out.endElement("EXCEPTION");
    }
  }
}

void select() :
{}
{
  ("(" select() ")")
  |
  (
  <SELECT>
         [LOOKAHEAD(2) <IDENTIFIER> "."] (expression() | "*") [<IDENTIFIER>]
    ("," [LOOKAHEAD(2) <IDENTIFIER> "."] (expression() | "*") [<IDENTIFIER>])*
  <FROM> (qualifiedName() | ("(" select() ")")) [LOOKAHEAD(2) <IDENTIFIER>]
    ("," (qualifiedName() | ("(" select() ")")) [LOOKAHEAD(2) <IDENTIFIER>] )*
  [<WHERE> expression()]
  [(<UNION> [<ALL>] | <INTERSECT> | <MINUS>) select() ]
  [LOOKAHEAD(2) <GROUP> <BY> qualifiedName() ("," qualifiedName())*]
  [LOOKAHEAD(2) <ORDER> <BY> qualifiedName() ("," qualifiedName())*]
  )
}
// Copyright (C) 2002 Albert Tumanov

void table() throws SAXException :
{ Token schema = null, name = null, tokenCreate = null, tokenTable = null;
}
{
  tokenCreate=<CREATE> [<GLOBAL_TEMPORARY>]
  tokenTable=<TABLE> (LOOKAHEAD(2) schema=ID()".")? name=ID()
  {
    String schemaString = "";
    if (schema != null) {
      schemaString = schema.toString();
    }
    // now start printing the package
    m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
    m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString.toString()));
    m_out.startElement("TABLE");
    // possibly, package comment is here
//    processPackageComment(tokenCreate);
//    processPackageComment(tokenPackage);
  }
  "(" tableColumn() ("," tableColumn())* ")"
  [LOOKAHEAD(2) <ON> <COMMIT> (<DELETE> | "PRESERVE") "ROWS"]
  //### [physicalProperties()]
  //### [tableProperties()]
  [";"]
  { m_out.endElement("TABLE"); }
}

void tableColumn() throws SAXException :
{ Token column = null;
  String datatype = null, constraint = null; }
{
  column=ID() datatype=datatype() [<_DEFAULT> expression()] [[<NOT> {constraint = "NOT NULL";}] <NULL>]
  {
    m_out.pushAttribute("NAME", String.valueOf(column));
    m_out.pushAttribute("TYPE", datatype);
    if (constraint != null)
      m_out.pushAttribute("CONSTRAINT", constraint);
    m_out.element("COLUMN");
  }
}

void view() throws SAXException :
{ Token schema = null, name = null, tokenCreate = null, tokenView = null;
}
{
  tokenCreate=<CREATE> [<OR> <REPLACE>]
  //###[[<NO>] <FORCE>]
  tokenView=<VIEW> (LOOKAHEAD(2) schema=ID()".")? name=ID()
  {
    String schemaString = "";
    if (schema != null) {
      schemaString = schema.toString();
    }
    // now start printing the view
    m_out.pushAttribute("NAME", purifyIdentifier(name.toString()));
    m_out.pushAttribute("SCHEMA", purifyIdentifier(schemaString.toString()));
    m_out.startElement("VIEW");
  }
  ["(" viewColumn() ("," viewColumn())* ")"]
  //### OF ... WITH OBJECT IDENTIFIER...
  <AS>
  select()
  //### WITH ...
  (";" | "/")
  { m_out.endElement("VIEW"); }
}

void viewColumn() throws SAXException :
{ Token column = null; }
{
  column=ID()
  {
    m_out.pushAttribute("NAME", String.valueOf(column));
    m_out.element("COLUMN");
  }
}

void comment() throws SAXException :
{ Token schema = null, table = null, column = null, name = null, tokenComment = null, tokenOn = null;
  String schemaString;
  Node commentedObjectNode;
  Element commentElement;
}
{
  <COMMENT> <ON> (
    ((tokenOn=<TABLE> | tokenOn=<OPERATOR> | tokenOn=<INDEXTYPE>) [LOOKAHEAD(2) schema=ID()"."] name=ID()) |
    (tokenOn=<COLUMN> [LOOKAHEAD(ID()"."ID()"."ID()) schema=ID()"."] table=ID() "." column=ID())
  )
  {
    schemaString = "";
    if (schema != null) {
      schemaString = schema.toString();
    }
    // find the database object where the comment belongs to
    if (name != null) {
      commentedObjectNode = m_out.findObjectNode(
        purifyIdentifier(schemaString), purifyIdentifier(name.toString()));
      if (commentedObjectNode == null) {
        System.out.println("Not found '" + purifyIdentifier(tokenOn.toString()) + " " +
          purifyIdentifier(schemaString) + "." +
          purifyIdentifier(name.toString()) +
          "' for comment.");
      }
    } else {
      Node commentedTableObjectNode = m_out.findObjectNode(
        purifyIdentifier(schemaString), purifyIdentifier(table.toString()));
      // find the COLUMN child
      commentedObjectNode = null;
      for (Node n = commentedTableObjectNode.getFirstChild(); n != null; n = n.getNextSibling()) {
        Element e = (Element) n;
        if (e.getTagName().equals("COLUMN") &&
           e.getAttribute("NAME").equalsIgnoreCase(purifyIdentifier(column.toString()))) {
           commentedObjectNode = e;
           break;
        }
      }
      if (commentedObjectNode == null) {
        System.out.println("Not found '" + purifyIdentifier(tokenOn.toString()) + " " +
          purifyIdentifier(schemaString) + "." +
          purifyIdentifier(table.toString()) + "." +
          purifyIdentifier(column.toString()) +
          "' for comment.");
      }
    }
    // now append the comment to the object
    commentElement = m_out.createElement("COMMENT");
  }
  <IS> tokenComment=<STRING_LITERAL>
  {
    String commentString = tokenComment.toString();
    commentElement.appendChild(m_out.createCDATASection(commentString.substring(1, commentString.length()-1)));
    if (commentedObjectNode != null) {
      commentedObjectNode.appendChild(commentElement);
    }
  }
  [";"]
}


// Copyright (C) 2002 Albert Tumanov

/* WHITE SPACE */

SKIP :
{
  " " | "\t" | "\n" | "\r" | "\f"
}

/* COMMENTS */

MORE :
{
  <"/**" ~["/"]> : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "--"(~["\n","\r"])* ("\n"|"\r"|"\r\n")?>
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SQL_STATEMENT_ENDED_SEMICOLON>
SKIP :
{
  <SQL_STATEMENT: ";" > : DEFAULT
}

<IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT,
 IN_SQL_STATEMENT_ENDED_SEMICOLON>
MORE :
{
  < ~[] >
}

/* PSEUDO-RESERVED WORDS */

TOKEN [IGNORE_CASE]:
{
<REPLACE: "REPLACE"> |
<DEFINER: "DEFINER"> |
<CURRENT_USER: "CURRENT_USER"> |
<SERIALLY_REUSABLE: "SERIALLY_REUSABLE"> |
<RESTRICT_REFERENCES: "RESTRICT_REFERENCES"> |
<EXCEPTION_INIT: "EXCEPTION_INIT"> |
<AUTONOMOUS_TRANSACTION: "AUTONOMOUS_TRANSACTION"> |
<LANGUAGE: "LANGUAGE">
}

/* PL/SQL RESERVED WORDS */

TOKEN [IGNORE_CASE]:
{
<ALL: "ALL"> |
<ADD: "ADD"> |
<ALTER: "ALTER"> |
<AND: "AND"> |
<ANY: "ANY"> |
<ARRAY: "ARRAY"> |
<AS: "AS"> |
<ASC: "ASC"> |
<AT: "AT"> |
<AUTHID: "AUTHID"> |
<AVG: "AVG"> |
<BEGIN: "BEGIN"> |
<BETWEEN: "BETWEEN"> |
<BINARY_INTEGER: "BINARY_INTEGER"> |
<BODY: "BODY"> |
<BOOLEAN: "BOOLEAN"> |
<BULK: "BULK"> |
<BY: "BY"> |
<BYTE: "BYTE"> |
<CASE: "CASE"> |
<CASCADE: "CASCADE"> |
<CHAR: "CHAR"> |
<CHAR_BASE: "CHAR_BASE"> |
<CHECK: "CHECK"> |
<CLOSE: "CLOSE"> |
<CLUSTER: "CLUSTER"> |
<COALESCE: "COALESCE"> |
<COLLECT: "COLLECT"> |
<COLUMN: "COLUMN"> |
<COMMENT: "COMMENT"> |
<COMMIT: "COMMIT"> |
<COMPRESS: "COMPRESS"> |
<CONNECT: "CONNECT"> |
<CONSTANT: "CONSTANT"> |
<CREATE: "CREATE"> |
<CURRENT: "CURRENT"> |
<CURRVAL: "CURRVAL"> |
<CURSOR: "CURSOR"> |
<DATE: "DATE"> |
<DAY: "DAY"> |
<DECLARE: "DECLARE"> |
<DECIMAL: "DECIMAL"> |
<_DEFAULT: "DEFAULT"> |
<DELETE: "DELETE"> |
<DESC: "DESC"> |
<DETERMINISTIC: "DETERMINISTIC"> |
<DISTINCT: "DISTINCT"> |
<DO: "DO"> |
<DROP: "DROP"> |
<ELSE: "ELSE"> |
<ELSIF: "ELSIF"> |
<END: "END"> |
<EXCEPTION: "EXCEPTION"> |
<EXCLUSIVE: "EXCLUSIVE"> |
<EXECUTE: "EXECUTE"> |
<EXISTS: "EXISTS"> |
<EXIT: "EXIT"> |
<EXTENDS: "EXTENDS"> |
<EXTRACT: "EXTRACT"> |
<FALSE: "FALSE"> |
<FETCH: "FETCH"> |
<FINAL: "FINAL"> |
<FLOAT: "FLOAT"> |
<FOR: "FOR"> |
<FORALL: "FORALL"> |
<FROM: "FROM"> |
<FUNCTION: "FUNCTION"> |
<GOTO: "GOTO"> |
<GROUP: "GROUP"> |
<HAVING: "HAVING"> |
<HEAP: "HEAP"> |
<HOUR: "HOUR"> |
<IF: "IF"> |
<IMMEDIATE: "IMMEDIATE"> |
<IN: "IN"> |
<INDEX: "INDEX"> |
<INDEXTYPE: "INDEXTYPE"> |
<INDICATOR: "INDICATOR"> |
<INSERT: "INSERT"> |
<INTEGER: "INTEGER"> |
<INTERFACE: "INTERFACE"> |
<INTERSECT: "INTERSECT"> |
<INTERVAL: "INTERVAL"> |
<INTO: "INTO"> |
<IS: "IS"> |
<ISOLATION: "ISOLATION"> |
<JAVA: "JAVA"> |
<LEVEL: "LEVEL"> |
<LIKE: "LIKE"> |
<LIMITED: "LIMITED"> |
<LOCK: "LOCK"> |
<LONG: "LONG"> |
<LOOP: "LOOP"> |
<MAP: "MAP"> |
<MAX: "MAX"> |
<MEMBER: "MEMBER"> |
<MIN: "MIN"> |
<MINUS: "MINUS"> |
<MINUTE: "MINUTE"> |
<MLSLABEL: "MLSLABEL"> |
<MOD: "MOD"> |
<MODE: "MODE"> |
<MONTH: "MONTH"> |
<NATURAL: "NATURAL"> |
<NATURALN: "NATURALN"> |
<NEW: "NEW"> |
<NEXTVAL: "NEXTVAL"> |
<NOCOPY: "NOCOPY"> |
<NOT: "NOT"> |
<NOWAIT: "NOWAIT"> |
<NULL: "NULL"> |
<NULLIF: "NULLIF"> |
<NUMBER: "NUMBER"> |
<NUMBER_BASE: "NUMBER_BASE"> |
<OBJECT: "OBJECT"> |
<OCIROWID: "OCIROWID"> |
<OF: "OF"> |
<ON: "ON"> |
<OPAQUE: "OPAQUE"> |
<OPEN: "OPEN"> |
<OPERATOR: "OPERATOR"> |
<OPTION: "OPTION"> |
<OR: "OR"> |
<ORDER: "ORDER"> |
<ORGANIZATION: "ORGANIZATION"> |
<OTHERS: "OTHERS"> |
<OUT: "OUT"> |
<PACKAGE: "PACKAGE"> |
<PARALLEL_ENABLE: "PARALLEL_ENABLE"> |
<PARTITION: "PARTITION"> |
<PCTFREE: "PCTFREE"> |
<PIPELINED: "PIPELINED"> |
<PLS_INTEGER: "PLS_INTEGER"> |
<POSITIVE: "POSITIVE"> |
<POSITIVEN: "POSITIVEN"> |
<PRAGMA: "PRAGMA"> |
<PRIOR: "PRIOR"> |
<PRIVATE: "PRIVATE"> |
<PROCEDURE: "PROCEDURE"> |
<PUBLIC: "PUBLIC"> |
<RAISE: "RAISE"> |
<RANGE: "RANGE"> |
<RAW: "RAW"> |
<REAL: "REAL"> |
<RECORD: "RECORD"> |
<REF: "REF"> |
<RELEASE: "RELEASE"> |
<RESULT_CACHE: "RESULT_CACHE"> |
<RETURN: "RETURN"> |
<REVERSE: "REVERSE"> |
<ROLLBACK: "ROLLBACK"> |
<ROW: "ROW"> |
<ROWID: "ROWID"> |
<ROWNUM: "ROWNUM"> |
<ROWTYPE: "ROWTYPE"> |
<SAVEPOINT: "SAVEPOINT"> |
<SECOND: "SECOND"> |
<SELECT: "SELECT"> |
<SEPARATE: "SEPARATE"> |
<SET: "SET"> |
<SHARE: "SHARE"> |
<SMALLINT: "SMALLINT"> |
<SPACE: "SPACE"> |
<SQL: "SQL"> |
<SQLCODE: "SQLCODE"> |
<SQLERRM: "SQLERRM"> |
<START: "START"> |
<STDDEV: "STDDEV"> |
<SUBTYPE: "SUBTYPE"> |
<SUCCESSFUL: "SUCCESSFUL"> |
<SUM: "SUM"> |
<SYNONYM: "SYNONYM"> |
<SYSDATE: "SYSDATE"> |
<TABLE: "TABLE"> |
<THEN: "THEN"> |
<TIME: "TIME"> |
<TIMESTAMP: "TIMESTAMP"> |
<TIMEZONE_REGION: "TIMEZONE_REGION"> |
<TIMEZONE_ABBR: "TIMEZONE_ABBR"> |
<TIMEZONE_MINUTE: "TIMEZONE_MINUTE"> |
<TIMEZONE_HOUR: "TIMEZONE_HOUR"> |
<TO: "TO"> |
<TRIGGER: "TRIGGER"> |
<TRUE: "TRUE"> |
<TYPE: "TYPE"> |
<UI: "UI"> |
<UNDER: "UNDER"> |
<WHEN: "WHEN"> |

// are they reserved or not ?
// most are not reserved, but cannot use just "WHERE" etc instead - resolves as identifier !
<WHERE: "WHERE"> |
<WHILE: "WHILE"> |
<UPDATE: "UPDATE"> |
<VARCHAR: "VARCHAR"> |
<VARCHAR2: "VARCHAR2"> |
<DOUBLE: "DOUBLE"> |
<DEC: "DEC"> |
<PRECISION: "PRECISION"> |
<INT: "INT"> |
<NUMERIC: "NUMERIC"> |
<SIGNTYPE: "SIGNTYPE"> |
<NCHAR: "NCHAR"> |
<NVARCHAR2: "NVARCHAR2"> |
<STRING: "STRING"> |
<UROWID: "UROWID"> |
<VARRAY: "VARRAY"> |
<VARYING: "VARYING"> |
<BFILE: "BFILE"> |
<BLOB: "BLOB"> |
<CLOB: "CLOB"> |
<NCLOB: "NCLOB"> |
<YEAR: "YEAR"> |
<LOCAL: "LOCAL"> |
<WITH: "WITH"> |
<ZONE: "ZONE"> |
<CHARACTER: "CHARACTER"> |
<VIEW: "VIEW"> |
<UNION: "UNION"> |
<GLOBAL_TEMPORARY: "GLOBAL TEMPORARY">
}

TOKEN :
{
< #LETTER: ["A"-"Z"] | ["a"-"z"]>
|
< #DIGIT: ["0"-"9"]>
|
< #_CHARACTER: <_CHARACTER_WO_ASTERISK> | "'" >
|
< #_CHARACTER_WO_ASTERISK: <LETTER> | <DIGIT> | "(" | ")" | "+" | "-" | "*" | "/" | "<" | ">"
 | "=" | "!" | "~" | "^" | ";" | ":" | "." | "@" | "%" | "," | "\"" | "#"
 | "$" | "&" | "_" | "|" | "{" | "}" | "?" | "[" | "]"
 | " " | "\t" >
|
< #DELIMITER: "+" | "%" | "'" | "\"" | "." | "/" | "(" | ")" | ":" | "," | "*" | "=" | "<" | ">" | "@" | ";" | "-">
|
< IDENTIFIER:
  ( <LETTER> ( <LETTER> | <DIGIT> | "$" | "_" | "#" )* )
  |
  ( "\"" (<_CHARACTER_WO_ASTERISK>)* "\"" )
>
|

< UNSIGNED_NUMERIC_LITERAL: <FLOAT_LITERAL> ( ["e","E"] (["-","+"])? <FLOAT_LITERAL> )? >
|
< #FLOAT_LITERAL: <INTEGER_LITERAL> ( "." <INTEGER_LITERAL> )? | "." <INTEGER_LITERAL> >
|
< #INTEGER_LITERAL: ( <DIGIT> )+ >
|

< #_WHATEVER_CHARACTER_WO_ASTERISK: (~["'"]) >
|
< CHARACTER_LITERAL: "'" (<_WHATEVER_CHARACTER_WO_ASTERISK>)? "'" >
|
< STRING_LITERAL: "'" (<_WHATEVER_CHARACTER_WO_ASTERISK> | "''")* "'" >
|
< #BOOLEAN_LITERAL: "TRUE" | "FALSE" >
}

Token ID(): {}
{
  (<IDENTIFIER>
  |
  <REPLACE> | <DEFINER> | <CURRENT_USER> | <SERIALLY_REUSABLE> | <RESTRICT_REFERENCES> |
  <EXCEPTION_INIT> | <AUTONOMOUS_TRANSACTION> | <LANGUAGE>
  |
  <ALL> | <ALTER> | <AND> | <ANY> | <ARRAY> | <AS> | <ASC> | <AT> | <AUTHID> | <AVG> |
  //  <BEGIN> |
  <BETWEEN> | <BINARY_INTEGER> | <BODY> | <BOOLEAN> | <BULK> | <BY> |
  <CASE> | <CHAR> | <CHAR_BASE> | <CHECK> | <CLOSE> | <CLUSTER> | <COALESCE> |
  <COLLECT> | <COMMENT> | <COMMIT> | <COMPRESS> | <CONNECT> | <CONSTANT> | <CREATE> |
  <CURRENT> | <CURRVAL> | <CURSOR> | <DATE> | <DAY> | <DECLARE> | <DECIMAL> |
  <_DEFAULT> | <DELETE> | <DESC> | <DISTINCT> | <DO> | <DROP> | <ELSE> | <ELSIF> |
  // <END> |
  <EXCEPTION> | <EXCLUSIVE> | <EXECUTE> | <EXISTS> | <EXIT> | <EXTENDS> |
  <EXTRACT> | <FALSE> | <FETCH> | <FLOAT> | <FOR> | <FORALL> | <FROM> |
  // <FUNCTION> |  // this causes bug 643043 Procedure w/o params appears as variable
  <GOTO> | <GROUP> | <HAVING> | <HEAP> | <HOUR> | <IF> | <IMMEDIATE> | <IN> |
  <INDEX> | <INDICATOR> | <INSERT> | <INTEGER> | <INTERFACE> | <INTERSECT> | <INTERVAL> |
  <INTO> | <IS> | <ISOLATION> | <JAVA> | <LEVEL> | <LIKE> | <LIMITED> | <LOCK> |
  <LONG> | <LOOP> | <MAX> | <MIN> | <MINUS> | <MINUTE> | <MLSLABEL> | <MOD> | <MODE> |
  <MONTH> | <NATURAL> | <NATURALN> | <NEW> | <NEXTVAL> | <NOCOPY> | <NOT> | <NOWAIT> |
  <NULL> | <NULLIF> | <NUMBER> | <NUMBER_BASE> | <OCIROWID> | <OF> | <ON> | <OPAQUE> |
  <OPEN> | <OPERATOR> | <OPTION> | <OR> | <ORDER> | <ORGANIZATION> | <OTHERS> | <OUT> |
  <PACKAGE> | <PARTITION> | <PCTFREE> | <PLS_INTEGER> | <POSITIVE> | <POSITIVEN> |
  // <PRAGMA> |
  <PRIOR> | <PRIVATE> |
  //  <PROCEDURE> | // this causes bug 643043 Procedure w/o params appears as variable
  <PUBLIC> | <RAISE> | <RANGE> | <RAW> | <REAL> |
  <RECORD> | <REF> | <RELEASE> | <RETURN> | <REVERSE> | <ROLLBACK> | <ROW> | <ROWID> |
  <ROWNUM> | <ROWTYPE> | <SAVEPOINT> | <SECOND> | <SELECT> | <SEPARATE> | <SET> | <SHARE> |
  <SMALLINT> | <SPACE> | <SQL> | <SQLCODE> | <SQLERRM> | <START> | <STDDEV> | <SUBTYPE> |
  <SUCCESSFUL> | <SUM> | <SYNONYM> | <SYSDATE> | <TABLE> | <THEN> | <TIME> | <TIMESTAMP> |
  <TIMEZONE_REGION> | <TIMEZONE_ABBR> | <TIMEZONE_MINUTE> | <TIMEZONE_HOUR> | <TO> | <TRIGGER> |
  <TRUE> | <TYPE> | <UI> | <UPDATE>
  |
  <VARCHAR> | <VARCHAR2> | <DOUBLE> | <DEC> | <PRECISION> | <INT> |
  <NUMERIC> | <SIGNTYPE> | <NCHAR> | <NVARCHAR2> | <STRING> | <UROWID> | <VARRAY> | <VARYING> | <BFILE> |
  <BLOB> | <CLOB> | <NCLOB> | <YEAR> | <LOCAL> | <WITH> | <ZONE> | <CHARACTER>)
  { return token; }
}

Token typeKeyword(): {}
{
  (
  <BOOLEAN> | <DATE> | <NUMBER> | <FLOAT> | <REAL> | <INTEGER> | <INT> | <SMALLINT>
  | <DECIMAL> | <NUMERIC> | <DEC> | <BINARY_INTEGER> | <NATURAL> | <NATURALN>
  | <POSITIVE> | <POSITIVEN> | <SIGNTYPE> | <VARCHAR2> | <VARCHAR> | <STRING> |
  <LONG> | <RAW> | <ROWID> | <CHAR> | <CHARACTER> | <MLSLABEL> | <BLOB> | <CLOB> | <BFILE> |
  <NCHAR> | <NVARCHAR2> | <NCLOB> | <PLS_INTEGER> | <TIME> | <TIMESTAMP> | <UROWID> |
//
  <ARRAY> | <AUTHID> |
  <CHAR_BASE> |
  <CURRVAL> |
  <HOUR> |
  <INTERVAL> |
  <MONTH> |
  <NUMBER_BASE> | <OCIROWID> |
  <RECORD> | <REF> |
  <ROW> |
  <ROWNUM> |
  <ROWTYPE> | <SECOND> | <SET> |
  <TABLE> |
  <TIMEZONE_REGION> | <TIMEZONE_ABBR> | <TIMEZONE_MINUTE> | <TIMEZONE_HOUR> |   <DOUBLE> | <PRECISION> |
  <VARRAY> |
  <YEAR> | <LOCAL> | <WITH> | <ZONE>)
  { return token; }
}
